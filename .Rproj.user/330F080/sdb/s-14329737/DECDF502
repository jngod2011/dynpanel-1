{
    "collab_server" : "",
    "contents" : "#' US States Production\n#'\n#' \\itemize{\n#' \\item{state}{the state}\n#' \\item{year}{the year}\n#' \\item{pcap}{private capital stock}\n#' \\item{hwy}{highway and streets}\n#' \\item{water}{water and sewer facilities}\n#' \\item{util}{other public buildings and structures}\n#' \\item{pc}{public capital}\n#' \\item{gsp}{gross state products}\n#' \\item{emp}{labor input measured by the employement in non--agricultural payrolls}\n#' \\item{unemp}{state unemployment rate}\n#' }\n#'\n#' @docType data\n#' @name Produc\n#' @usage data(Produc)\n#' @format A data frame with 816 rows and 10 variables\nNULL\n\nginv <- function(x, tol = sqrt(.Machine$double.eps))\n{\n  ## Generalized Inverse of a Matrix\n  dnx <- dimnames(x)\n  if(is.null(dnx)) dnx <- vector(\"list\", 2)\n  s <- svd(x)\n  nz <- s$d > tol * s$d[1]\n  structure(\n    if(any(nz)) s$v[, nz] %*% (t(s$u[, nz])/s$d[nz]) else x,\n    dimnames = dnx[2:1])\n}\n#' @importFrom gtools smartbind\npandyn<-function(z,p,meth=c(0,1,2,3,4)){\n  NT=nrow(z)\n  k=ncol(z)\n  Tmin=min(z[,2])\n  Tmax=max(z[,2])\n  T=Tmax-Tmin+1\n  T0=T-p-1\n  N=NT/T\n  range0=Tmax\n  range1=Tmin\n  zy<-0\n  zx<-0\n  zwz<-0\n  yy<-0\n  xy<-0\n  xx<-0\n  sx<-0\n  sy<-0\n  sxx<-0\n  sxy<-0\n  ssy<-0\n  ssx<-0\n  syy<-0\n  sT<-0\n  NTges<-0\n  if(meth==0){\n    ivn1=T0*(T0+1)/2 + (k-3) + N/10\n    ivn2=T0 + T0*(k-3) + N/10\n    ivn3=T0+k-3+N/10\n    meth=4\n    if(ivn1>N){\n      meth=3\n      if(ivn2>N){\n        meth=2\n        if(ivn3>N){\n          meth=1\n\n        }\n      }\n    }\n  }\n\n  w=matrix(0,T0,T0)\n  w[1, 1:2]=cbind(2,-1)\n  w[T0,T0-1]=-1\n  w[T0,T0]=2\n  i=2\n  while(i<=T0-1){\n\n    w[i,i-1] = -1\n    w[i,i] = 2\n    w[i,i+1] = -1\n    i=i+1\n  }\n  #------------------------------------------------\n  pos=1\n  N=0\n  while(pos< NT-2) {\n    yi=matrix(0,1,1)\n    xi=matrix(0,1,k-3)\n    dyi=matrix(0,2,1)\n    dxi=matrix(0,2,k+p-3)\n    ctl=dyi\n    dvec=matrix(0,T,1)\n    Ti=0\n    year=Tmin\n    while(year<=Tmax){\n\n      if(z[pos,2]==year){\n        dvec[year-Tmin+1]=1\n        yi=rbind(yi,z[pos,3]);\n        xi=smartbind(xi,z[pos,4:k])\n        pos=pos+1\n      }\n\n      else{\n        yi=rbind(yi,(z[pos,3]))\n\n        xi=rbind(xi,(z[pos,4:k]))\n      }\n      if (year>=Tmin+p+1){\n        d=0\n        m=nrow(yi)\n        #s<-0-p-2\n        s<-as.numeric(m-p-2)\n        rr<-as.numeric(m-1)\n        if (sum(dvec[s:rr])==p+2)  {\n          d=1\n        }\n\n        #d=1\n        ctl=rbind(ctl,d)\n        dyi=rbind(dyi,(d*(yi[m]-yi[m-1])))\n        ss<-as.numeric(p-1)\n        i<- as.numeric(m-p)\n        j<-as.numeric(m-1)\n        #dfy=yi[j:i]\n        ii<-as.numeric(m-2)\n        jj<-as.numeric(m-ss)\n        #dffy=yi[ii]\n        LagDep=t(yi[j:i]-yi[ii])\n        dxi=smartbind(dxi,d*(cbind((xi[m,]-xi[m-1,]),LagDep )))\n\n        Ti=Ti+d\n      }\n      year=year+1\n    }\n    yi=yi[1:T+1]\n    xi=xi[1:T+1,]\n    dyi=dyi[3:nrow(dyi)]\n    dxi=dxi[3:nrow(dxi),]\n    ctl=ctl[3:nrow(ctl)]\n\n    ff=as.numeric(T-2)\n    if (meth==1){\n      zi=yi[p:ff]\n      j=2\n      while (j<=p){\n        zi=cbind(zi,yi[p-j+1:T-j-1])\n        j=j+1\n      }\n      kk=as.numeric(k-3)\n      zi=cbind(zi,cbind((xi[p+3:T-2,]-xi[p:ff,]),dxi[,1:kk]) )\n      zi=t(zi)\n\n    }\n\n    if (meth==2) {\n\n      zi=(matrix(1,T0,1)*yi[p])\n      j=p+1\n      while (j<=T-2){\n        z00=matrix(0,j-p,1)\n        z11=matrix(1,T-j-1,1)*yi[j]\n        z0=rbind(z00,z11)\n        zi=cbind(zi,z0)\n        j=j+1\n      }\n      q<-as.numeric(k-3)\n      dx=dxi[,1:q]\n      zi=rbind(zi,t(dx))\n    }\n\n    if (meth==3)  {\n      zi=(matrix(1,T0,1)*yi[p])\n      j=p+1\n      while (j<=T-2){\n        z00=matrix(0,j-p,1)\n        z11=matrix(1,T-j-1,1)*yi[j]\n        z0=rbind(z00,z11)\n        zi=cbind(zi,z0)\n        j=j+1\n      }\n\n      ein=diag(T0)\n      z0=matrix(1,(k-3)*T0,T0)\n      j=1\n      while (j<=T0){\n        q<-as.numeric(k-3)\n        z0[,j]=kronecker(ein[,j],t(dxi[j,1:q]))\n        j=j+1\n      }\n      zi=rbind(zi,z0)\n    }\n\n    if (meth==4){\n      z0=cbind(yi[1:p],matrix(0,p,T-p-2))\n      zi=z0\n      i=p+1\n      while (i<=T-3) {\n        z0=cbind(yi[1:i],matrix(0,i,T-i-2))\n        z0=cbind(matrix(0,i,i-p),z0)\n        zi=rbind(zi,z0)\n        i=i+1\n      }\n      qq<-as.numeric(T-2)\n      z0=cbind(matrix(0,T-2,T-2-p),yi[1:qq])\n      zi=rbind(zi,z0)\n      q<-as.numeric(k-3)\n      zi=rbind(zi,t(dxi[,1:q]))\n    }\n    Ti=Ti-1\n    range0=min(rbind(range0,Ti))\n    range1=max(rbind(range1,Ti))\n    y=yi[p+2:T-1]\n    x=xi[p+2:T-1,]\n    zi=t(t(zi)*ctl)\n    dxi<-as.matrix(dxi)\n    sxx=sxx+t(dxi)%*%dxi\n    sxy=sxy+t(dxi)%*%dyi\n    syy=syy+t(dyi)%*%dyi\n    sy=sy+colSums(as.matrix(dyi))\n    sx=sx+t(colSums(dxi))\n    zy=zy+zi%*%dyi\n    zx=zx+zi%*%dxi\n    zwz=zwz+zi%*%w%*%t(zi)\n    yy=yy+t(dyi)%*%dyi\n    xy=xy+t(dxi)%*%dyi\n    xx=xx+t(dxi)%*%dxi\n    sT=sT+sum(ctl)\n    N=N+1\n    NTges=NTges+sum(ctl)\n  }\n  k=k-3\n  zwz=ginv(zwz)\n  eig=eigen(t(zx)%*%zwz%*%zx)\n  r=eig$values\n\n  bgmm=ginv(t(zx)%*%zwz%*%zx)%*%t(zx)%*%zwz%*%zy\n  sige=syy-2*t(bgmm)%*%sxy+t(bgmm)%*%sxx%*%bgmm\n  sige=as.numeric(sige/2/sT )\n  SEbgmm=sige*ginv(t(zx)%*%zwz%*%zx)\n\n  SEbgmm=sqrt(diag(SEbgmm))\n  tval=bgmm/SEbgmm\n\n  m=zy-zx%*%bgmm\n  J=t(m)%*%zwz%*%m/sige\n\n  cov=t(bgmm)%*%(as.vector(sxy)-as.vector(sx)*as.numeric(sy/sT))/sT\n  gg<-tcrossprod(as.vector(sx))/sT\n  var1=t(bgmm)%*%(sxx-gg)%*%bgmm/sT\n  var2=(syy-sy^2/sT)/sT\n  R2=cov^2/var1/var2\n\n  df=nrow(zx)-k-p\n  pval = 2*pt(-abs(tval), df=df)\n  Jpval=1-pchisq(J,df=df)\n  if(meth==4){iv<-\"Arellano Bond (1991)\"}\n  if(meth==0){iv<-\"Automatic selection of appropriate IV matrix\"}\n  if(meth==1){iv<-\" GMM estimator with the smallest set of instruments\"}\n  if(meth==2){iv<-\"A reduced form of IV from method 3\"}\n  if(meth==3){iv<-\"IV matrix where the number of moments grows with k.T\"}\n  list(coefficients=bgmm,std=SEbgmm,tval=tval,pval=pval, Jstat=J, Jpval=Jpval, R2=R2,NTges=NTges,N=N,iv=iv )\n}\n#' method\n#'\n#' @author Zaghdoudi Taha\n#' @param x a numeric design matrix for the model.\n#' @param ... not used\n#' @export\ndpd<- function(x,...){UseMethod(\"dpd\") }\n\n\n\ndpd.default <- function(z,p,meth=c(0,1,2,3,4),...)\n{\n  if(meth==0){ est <- pandyn(z,p,0)}\n  if(meth==1){ est <- pandyn(z,p,1)}\n  if(meth==2){ est <-pandyn(z,p,2)}\n  if(meth==3){ est <- pandyn(z,p,3)}\n  if(meth==4){ est <- pandyn(z,p,4)}\n  est$call <- match.call()\n  class(est) <- \"dpd\"\n  est\n\n}\nprint.dpd <- function(x,...)\n{\n  cat(\"Call:\\n\")\n  print(x$call)\n  cat(\"\\nCoefficients:\\n\")\n  print(x$coefficients)\n}\n\n#' Summary\n#'\n#' @param object is the object of the function\n#' @param ... not used\n#' @importFrom stats pchisq printCoefmat pt\n#' @export\nsummary.dpd<-function(object,...)\n{\n  res<-cbind(object$coefficients,object$std, object$tval,object$pval)\n  colnames(res)<-c(\"Estimate\",\"SE \",\"t-value\",\"Pvalue\")\n  cat(\"\\nGMM-Estimation of the Dynamic Panel Data Models:\\n\")\n  cat(\"Instruments according to method: \\n\", object$iv,\"\\n\")\n  printCoefmat(res,has.Pvalue = TRUE)\n  cat(\"\\nNumber of groups :\",object$N,\"Number of obs :\",object$NTges,\"\\n\")\n  cat(\"R-square :\",object$R2,\"\\n\")\n  cat(\"Hansen's J-statistic: \",object$Jstat,\"Pvalue: \",object$Jpval,\"\\n\")\n\n\n\n}\n#' formula\n#'\n#' @param formula PIB~INF+TIR\n#' @param data the dataframe\n#' @param index : id is the name of the identity groups and time is the time per group\n#' @param p scalar, autoregressive order for dependent variable\n#' @param meth scalar, indicator for the Instruments to use\n#' @param ... not used\n#' @importFrom stats model.frame model.matrix model.response  update\n#' @export\ndpd.formula <-function(formula,data=list(),index=c(\"id\",\"time\"),p,meth=c(0,1,2,3,4),...)\n{\n  mff <- update(formula, ~ . -1)\n  mf <- model.frame(mff, data=data)\n  x <- model.matrix(attr(mf, \"terms\"), data=mf)\n  y <- model.response(mf)\n  idx=data[,index]\n  z=cbind(idx,y,x)\n  if(meth==0){ est <- dpd.default(z,p,0,...)}\n  if(meth==1){ est <- dpd.default(z,p,1,...)}\n  if(meth==2){ est <- dpd.default(z,p,2,...)}\n  if(meth==3){ est <- dpd.default(z,p,3,...)}\n  if(meth==4){ est <- dpd.default(z,p,4,...)}\n  est$call <- match.call()\n  est$equa <- formula\n  est\n}\n",
    "created" : 1472222289451.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "376723479",
    "id" : "DECDF502",
    "lastKnownWriteTime" : 1472388387,
    "last_content_update" : 1472388387592,
    "path" : "~/dynpanel/R/dynpanel.R",
    "project_path" : "R/dynpanel.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}